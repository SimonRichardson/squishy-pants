<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/match.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">72.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">382</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">52.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">3.25</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">//
//   # Match
//
//   Monad pattern matching.
//
//      var m = _.match([
//                    [&#039;Cons(Some(a), _)&#039;, function(a) { return a; }],
//                    [&#039;Cons(None, _)&#039;, function(x, y, z) { return 0; }],
//                    [&#039;_&#039;, function() { return -1; }]);
//          m(_.Cons(_.Some(1), _.Nil));
//
//   * `match(patterns)(value)` - Construction.
//
var match = (function() {

    //
    //  ## Token
    //
    //  The token type encodes the presence of a certain data type from
    //  the parser.
    //
    var Token = taggedSum(&#039;Token&#039;, {
            TString: [&#039;string&#039;],
            TNumber: [&#039;number&#039;],
            TIdent: [&#039;ident&#039;],
            TWildcard: []
        }),

        //
        //  ### isToken(a)
        //
        //  Returns `true` if `a` is an instance of `token`.
        //
        isToken = isInstanceOf(Token),

        //
        //  ### Parser
        //
        //  Monadic parser creation.
        //
        regexp = Parser.regexp,
        string = Parser.string,
        word = regexp(/^.[^&quot;]*/),
        quote = regexp(/^&quot;/),
        number = regexp(/^[\+\-]?\d+(\.\d+)?/),
        ident = regexp(/^[a-zA-Z\_][a-zA-Z0-9\_\-\.]*/),
        wildcard = regexp(/^\_/),
        comma = regexp(/^(\s|\,|\s)*/),
        leftBracket = string(&#039;(&#039;),
        rightBracket = string(&#039;)&#039;),
        optionalWhitespace = regexp(/^\s*/),
        emptyString = string(&#039;&#039;),
        wildcardAsString = &#039;_&#039;,

        /* Tokens */
        stringToken = quote.chain(function() {
            return word.skip(quote);
        }).map(function(a) {
            return Token.TString(a);
        }),
        emptyStringToken = quote.chain(function() {
            return emptyString.skip(quote);
        }).map(function() {
            return Token.TString([&#039;&#039;]);
        }),
        numberToken = number.map(function(a) {
            return Token.TNumber(parseFloat(a, 10));
        }),
        identToken = ident.map(function(a) {
            return Token.TIdent(a);
        }),
        wildcardToken = wildcard.map(function() {
            return Token.TWildcard;
        }),

        /* Block */
        block = identToken.many().also(function() {
            return leftBracket.skip(optionalWhitespace).chain(function() {
                return expr.many().skip(rightBracket);
            });
        }),
        expr = block.orElse(wildcardToken)
                    .orElse(emptyStringToken)
                    .orElse(stringToken)
                    .orElse(numberToken)
                    .orElse(identToken)
                    .skip(comma),
        parser = block.orElse(wildcardToken)
                      .orElse(identToken),

        /* Start extracting the possible patterns */
        extract = curry(function(args, key, x) {
            var result = recursiveMatch(args, x, key),
                flattened = squishy.chain(result, function(a) {
                    return recursiveFlatten([a]);
                }),
                failed = squishy.exists(flattened, function(a) {
                    return a.isFailure;
                }),
                filtered,
                mapped;

            if (failed) {
                return Option.None;
            } else {
                filtered = squishy.filter(flattened, function(a) {
                    return !a.value.isWildcard;
                });
                mapped = squishy.map(filtered, function(a) {
                    return a.extract();
                });
                return Option.of(mapped);
            }
        }),

        //
        //  ## match(patterns)
        //
        //  Constructor for the patterns expression.
        //
        match = function(patterns) {
            var env = this,
                compile = compiler();

            return function(argument) {
                var key = Token.TIdent([functionName(argument)]),
                    args = supplied(argument, fields(argument, key)).getOrElse(constant([])),
                    result = until(patterns, function(c) {
                        var result = compile(c[0]),
                            value = result.fold(
                                extract(args, key),
                                constant(result)
                            );

                        return value.map(
                            function(x) {
                                return c[1].apply(env, x);
                            }
                        );
                    });

                return result.fold(
                    identity,
                    function() {
                        /* Handle the default case */
                        var defaultCase = env.find(patterns, function(x) {
                            return x[0] === wildcardAsString;
                        });
                        if (isArray(defaultCase)) {
                            return defaultCase[1].apply(this, []);
                        }

                        throw new TypeError(&#039;No default case found.&#039;);
                    }
                );
            };
        };

    /* Get the head of the parsed stream */
    function head(a) {
        if (isArray(a)) {
            return squishy.flatten(a)[0];
        }
        return a;
    }

    /* Get the tail of the parsed stream */
    function tail(a) {
        if (isArray(a)) {
            return a[0].slice(1)[0];
        }
        return [a];
    }

    /* Recursively flatten the arguments */
    function recursiveFlatten(a) {
        return squishy.fold(a, [], function(x, y) {
            return squishy.concat(x, isArray(y) ? recursiveFlatten(y) : y);
        });
    }

    /* Compile the stream into an array and cache the results for later */
    function compiler() {
        var cache = {};
        return function(stream) {
            var result;
            if (!(stream in cache)) {
                result = parser.parse(stream).fold(
                    Option.of,
                    Option.empty
                );

                cache[stream] = result;
            }
            return cache[stream];
        };
    }

    /* Return the siblings of the taggedSum  */
    function siblings(value) {
        if (isObject(value) &amp;&amp; value._constructors) {
            return Object.keys(value._constructors);
        }
        return [];
    }

    /* Return the fields of the taggedSum */
    function fields(a, b) {
        var key = b.isIdent ? Option.of(b.ident) : Option.empty();
        return key.match({
            Some: function(x) {
                return a._constructors[x];
            },
            None: constant([])
        });
    }

    /* Return the values from the value using the fields of the taggedSum */
    function supplied(value, fields) {
        if(isArray(fields) &amp;&amp; fields.length &gt; 0) {
            return Option.Some(squishy.select(value, fields));
        }
        return Option.None;
    }

    /* Continue to iterate through the array until an Option.Some is located */
    function until(a, f) {
        var result,
            i;

        for(i = 0; i &lt; a.length; i++) {
            result = f(a[i]);
            if (result.isSome) {
                return result;
            }
        }

        return Option.None;
    }

    /* Recursively match the parsed stream values against the taggedSum values */
    function recursiveMatch(args, a, key) {
        var zipped,
            rest;

        if (head(a).equal(key)) {

            zipped = squishy.zip(tail(a), args);

            return squishy.map(
                zipped,
                function(tuple) {
                    var name = tuple._1,
                        value = tuple._2,
                        possibleKey = Token.TIdent([functionName(value)]),
                        possibleArgs,
                        possibleSibling;

                    if (squishy.isArray(name)) {
                        possibleArgs = supplied(value, fields(value, possibleKey));

                        return possibleArgs.fold(
                            function(x) {
                                return recursiveMatch(x, [name], possibleKey);
                            },
                            function() {
                                return Attempt.Failure([&#039;Invalid tokens&#039;]);
                            }
                        );
                    } else if (!name.isWildcard) {
                        possibleSibling = squishy.exists(siblings(value), function(x) {
                            return name.isIdent ? squishy.equal(name.ident[0], x) : false;
                        });

                        if (possibleSibling &amp;&amp; name.similar(value)) {
                            return Attempt.of(Token.TWildcard);
                        } else if(!possibleSibling &amp;&amp; name.isIdent) {
                            return Attempt.of(value);
                        } else if(name.equal(value) || name.similar(value)) {
                            return Attempt.of(value);
                        }

                        return Attempt.Failure([&#039;Invalid token&#039;]);
                    } else {
                        return Attempt.of(Token.TWildcard);
                    }
                }
            );
        } else {
            return [Attempt.Failure([&#039;Invalid namespace&#039;, head(a), key])];
        }
    }

    //
    //  ## equal(b)
    //
    //  Compare two option values for equality
    //
    Token.prototype.equal = function(b) {
        if (b.wildcard) return true;

        var env = this;
        return env.match({
            TIdent: function(x) {
                var last0 = squishy.last(env.namespace()),
                    last1 = b.isIdent ? squishy.last(b.namespace()) : [];
                return squishy.equal(last0, last1);
            },
            TNumber: function(x) {
                return b.isNumber &amp;&amp; squishy.equal(b.number, x);
            },
            TString: function(x) {
                return b.isString &amp;&amp; squishy.equal(b.string, x);
            },
            TWildcard: constant(true)
        });
    };

    //
    //  ## similar(b)
    //
    //  Compare two option values for similarity
    //
    Token.prototype.similar = function(b) {
        if (b.wildcard) return true;

        return this.match({
            TIdent: function(c) {
                return squishy.equal(c[0], functionName(b));
            },
            TNumber: function(c) {
                return isNumber(b) &amp;&amp; squishy.equal(c, b);
            },
            TString: function(c) {
                return isString(b) &amp;&amp; squishy.equal(c[0], b);
            },
            TWildcard: constant(true)
        });
    };

    Token.TIdent.prototype.namespace = function() {
        return this.ident.join(&#039;&#039;).split(&#039;.&#039;);
    };

    //
    //  ## TIdent(x)
    //
    //  Constructor to represent the ident token with a value, `x`.
    //
    Token.TIdent.prototype.isIdent = true;
    Token.TIdent.prototype.isNumber = false;
    Token.TIdent.prototype.isString = false;
    Token.TIdent.prototype.isWildcard = false;

    //
    //  ## TNumber(x)
    //
    //  Constructor to represent the number token with a value, `x`.
    //
    Token.TNumber.prototype.isIdent = false;
    Token.TNumber.prototype.isNumber = true;
    Token.TNumber.prototype.isString = false;
    Token.TNumber.prototype.isWildcard = false;

    //
    //  ## TString(x)
    //
    //  Constructor to represent the string token with a value, `x`.
    //
    Token.TString.prototype.isIdent = false;
    Token.TString.prototype.isNumber = false;
    Token.TString.prototype.isString = true;
    Token.TString.prototype.isWildcard = false;

    //
    //  ## TWildcard(x)
    //
    //  Constructor to represent the wildcard token.
    //
    Token.TWildcard.isIdent = false;
    Token.TWildcard.isNumber = false;
    Token.TWildcard.isString = false;
    Token.TWildcard.isWildcard = true;

    //
    //  Return the match function
    //
    return match;
})();

//
//  append methods to the squishy environment.
//
squishy = squishy
    .property(&#039;match&#039;, match);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
